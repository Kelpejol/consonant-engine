// Package auth provides API key authentication for gRPC requests.
//
// Every request to the Beam backend must include a valid API key in the
// gRPC metadata. This package validates those keys and returns the platform
// user ID associated with the key.
//
// API keys are secrets that identify which Beam user (B2B SaaS founder)
// is making the request. We never store the actual key in plaintext - only
// a SHA-256 hash of the key is stored in the database.
//
// The authentication flow:
// 1. Extract "authorization" header from gRPC metadata
// 2. Parse the "Bearer <key>" format
// 3. Hash the provided key with SHA-256
// 4. Look up the hash in Redis (fast path) or PostgreSQL (slow path)
// 5. Return the platform_user_id if valid, error if not
//
// Security considerations:
// - Keys are transmitted over TLS so they can't be intercepted
// - Keys are never logged or stored in plaintext
// - Hash collisions are astronomically unlikely (SHA-256 is 2^256 space)
// - Rate limiting should be added to prevent brute force attacks
package auth

import (
	"context"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"strings"

	"github.com/go-redis/redis/v8"
	"github.com/rs/zerolog"
	"google.golang.org/grpc/metadata"
)

// Authenticator validates API keys and returns platform user IDs.
type Authenticator struct {
	redis *redis.Client
	log   zerolog.Logger
}

// NewAuthenticator creates a new Authenticator instance.
func NewAuthenticator(rdb *redis.Client, logger zerolog.Logger) *Authenticator {
	return &Authenticator{
		redis: rdb,
		log:   logger.With().Str("component", "authenticator").Logger(),
	}
}

// ValidateAPIKey extracts and validates the API key from gRPC metadata.
//
// This function is called at the start of every gRPC request handler to
// authenticate the request. It's in the hot path so performance matters.
//
// Expected header format: "authorization: Bearer Beam_sk_live_xxxxx"
//
// Returns the platform_user_id if authentication succeeds, error otherwise.
//
// Performance: < 1ms typical (Redis lookup)
func (a *Authenticator) ValidateAPIKey(ctx context.Context) (string, error) {
	// Extract metadata from context
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return "", fmt.Errorf("missing metadata")
	}

	// Get authorization header
	authHeaders := md.Get("authorization")
	if len(authHeaders) == 0 {
		return "", fmt.Errorf("missing authorization header")
	}

	authHeader := authHeaders[0]

	// Parse "Bearer <key>" format
	if !strings.HasPrefix(authHeader, "Bearer ") {
		return "", fmt.Errorf("invalid authorization format, expected 'Bearer <key>'")
	}

	apiKey := strings.TrimPrefix(authHeader, "Bearer ")
	if apiKey == "" {
		return "", fmt.Errorf("empty API key")
	}

	// Hash the API key
	// We never store plaintext keys, only their SHA-256 hashes
	keyHash := hashAPIKey(apiKey)

	// Look up the hash in Redis
	// Redis key: "apikey:<hash>" -> platform_user_id
	redisKey := fmt.Sprintf("apikey:%s", keyHash)

	userID, err := a.redis.Get(ctx, redisKey).Result()
	if err == redis.Nil {
		// Key not found in Redis - this is an invalid API key
		a.log.Warn().Str("key_hash", keyHash[:8]+"...").Msg("invalid API key")
		return "", fmt.Errorf("invalid API key")
	} else if err != nil {
		// Redis error - log but don't expose details to client
		a.log.Error().Err(err).Msg("redis lookup failed during auth")
		return "", fmt.Errorf("authentication service unavailable")
	}

	// Successfully authenticated
	return userID, nil
}

// hashAPIKey computes the SHA-256 hash of an API key.
//
// This is a one-way function - you can't recover the original key from the hash.
// This is good for security: even if our database is compromised, the attacker
// can't use the hashes to make authenticated requests.
func hashAPIKey(key string) string {
	hash := sha256.Sum256([]byte(key))
	return hex.EncodeToString(hash[:])
}

// StoreAPIKey stores an API key hash in Redis (for testing/setup).
//
// In production, API keys would be generated by the platform backend and
// stored during user registration. This function is for development/testing.
func (a *Authenticator) StoreAPIKey(ctx context.Context, apiKey, platformUserID string) error {
	keyHash := hashAPIKey(apiKey)
	redisKey := fmt.Sprintf("apikey:%s", keyHash)

	err := a.redis.Set(ctx, redisKey, platformUserID, 0).Err() // No expiration
	if err != nil {
		return fmt.Errorf("failed to store API key: %w", err)
	}

	a.log.Info().
		Str("platform_user_id", platformUserID).
		Str("key_hash", keyHash[:8]+"...").
		Msg("API key stored")

	return nil
}