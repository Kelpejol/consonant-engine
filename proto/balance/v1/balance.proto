// balance.proto defines the gRPC service contract for Consonant's balance checking API.
//
// This protocol defines the three critical operations that enable real-time AI cost enforcement:
// 1. CheckBalance - Pre-flight validation before AI requests (must complete in <5ms)
// 2. DeductTokens - Real-time deduction during streaming (batched for performance)
// 3. FinalizeRequest - Stream-end reconciliation with exact provider data
//
// The API is designed for sub-millisecond latency in the hot path and uses gRPC for
// efficient binary serialization and HTTP/2 multiplexing.

syntax = "proto3";

package consonant.balance.v1;

option go_package = "github.com/consonant/backend/pkg/proto/balance/v1;balancev1";

// BalanceService provides real-time AI cost enforcement operations.
//
// This service sits in the critical path of every AI request. Performance is paramount:
// - CheckBalance must complete in under 5 milliseconds
// - DeductTokens must handle 10,000+ concurrent calls per second
// - All operations must be atomic to prevent race conditions
service BalanceService {
  // CheckBalance performs pre-flight validation and reserves grains for a request.
  //
  // This is called by the SDK before allowing an AI request to proceed. It atomically:
  // 1. Reads the customer's available balance (balance - reserved)
  // 2. Checks if they can afford the estimated worst-case cost
  // 3. If yes, increments the reservation counter to prevent race conditions
  // 4. Returns approval with a secure request token for subsequent operations
  //
  // Performance: Typically completes in 2-4ms via Redis Lua script execution.
  // Failures: Returns rejected=false if insufficient balance or service degraded.
  rpc CheckBalance(CheckBalanceRequest) returns (CheckBalanceResponse);

  // DeductTokens deducts grains as tokens are consumed during streaming.
  //
  // This is called repeatedly during streaming, batched every 50 tokens to minimize
  // backend traffic. It atomically decrements the customer's balance and updates
  // the request tracking hash with consumed amounts.
  //
  // Performance: Completes in 1-3ms. Called 10-30 times per streaming request.
  // Failures: Returns success=false if balance exhausted, triggering stream kill.
  rpc DeductTokens(DeductTokensRequest) returns (DeductTokensResponse);

  // FinalizeRequest performs final reconciliation when streaming completes or is killed.
  //
  // This is called once at stream-end with exact token counts from the AI provider.
  // It calculates the precise cost, compares to streaming deductions, refunds any
  // overcharge, releases the reservation, and marks the request complete.
  //
  // Performance: Completes in 3-8ms. Only called once per request.
  // Failures: Retried by SDK with exponential backoff until successful.
  rpc FinalizeRequest(FinalizeRequestRequest) returns (FinalizeRequestResponse);

  // GetBalance returns current balance without making reservations.
  //
  // This is a read-only operation for dashboard queries and health checks.
  // Not used in the hot path.
  rpc GetBalance(GetBalanceRequest) returns (GetBalanceResponse);
}

// CheckBalanceRequest contains all data needed for pre-flight validation.
message CheckBalanceRequest {
  // customer_id uniquely identifies the end customer making this request.
  // Format: "cus_" followed by alphanumeric identifier from customer's system.
  // Example: "cus_abc123xyz"
  string customer_id = 1;

  // estimated_grains is the worst-case cost calculated by the SDK.
  // Formula: (prompt_tokens * input_price) + (max_tokens * output_price)
  // This is always pessimistic to ensure we never under-reserve.
  int64 estimated_grains = 2;

  // buffer_multiplier applies an additional safety factor to the estimate.
  // Conservative mode: 1.2 (reserve 20% extra)
  // Aggressive mode: 1.0 (reserve exact estimate)
  // The final reservation = estimated_grains * buffer_multiplier
  double buffer_multiplier = 3;

  // request_id is a unique identifier for this specific AI request.
  // Generated by SDK, used to track the request through its lifecycle.
  // Format: "req_" followed by timestamp and random string.
  // Example: "req_1706234567_a9f3k2"
  string request_id = 4;

  // metadata contains additional request information for logging and analytics.
  RequestMetadata metadata = 5;
}

// RequestMetadata carries non-critical information about the request.
message RequestMetadata {
  // model is the AI model being requested (e.g., "gpt-4", "claude-3-opus").
  string model = 1;

  // max_tokens is the maximum completion length parameter.
  int32 max_tokens = 2;

  // prompt_tokens is the SDK's count of input tokens.
  int32 prompt_tokens = 3;

  // custom_properties allows SDK users to attach arbitrary metadata.
  // Useful for tracking which feature triggered the request, user cohorts, etc.
  map<string, string> custom_properties = 4;
}

// CheckBalanceResponse returns the result of pre-flight validation.
message CheckBalanceResponse {
  // approved indicates whether the request can proceed.
  // true: Customer has sufficient balance, reservation made
  // false: Insufficient balance or service degraded
  bool approved = 1;

  // remaining_balance shows grains available after this reservation.
  // Only meaningful when approved=true.
  // Can be used by SDK to warn users approaching zero balance.
  int64 remaining_balance = 2;

  // request_token is a cryptographic token required for subsequent operations.
  // The SDK must include this in DeductTokens and FinalizeRequest calls.
  // Prevents replay attacks and ensures only approved requests can deduct.
  // Format: SHA-256 hash encoded as hex string.
  string request_token = 3;

  // rejection_reason explains why approval was denied.
  // Only populated when approved=false.
  // Examples: "INSUFFICIENT_BALANCE", "SERVICE_DEGRADED", "RATE_LIMITED"
  string rejection_reason = 4;

  // reserved_grains shows the exact amount reserved for this request.
  // Formula: estimated_grains * buffer_multiplier
  // Used by SDK for logging and debugging.
  int64 reserved_grains = 5;
}

// DeductTokensRequest deducts grains for tokens consumed during streaming.
message DeductTokensRequest {
  // customer_id identifies the customer (must match CheckBalance call).
  string customer_id = 1;

  // request_id identifies the request (must match CheckBalance call).
  string request_id = 2;

  // request_token proves this SDK was approved to make deductions.
  // Must match the token returned by CheckBalance.
  string request_token = 3;

  // tokens_consumed is the number of tokens in this batch.
  // SDK accumulates tokens until reaching batch threshold (typically 50).
  int32 tokens_consumed = 4;

  // model identifies which AI model to use for pricing.
  string model = 5;

  // is_completion distinguishes output tokens (true) from input tokens (false).
  // Output tokens typically cost 2-3x more than input tokens.
  bool is_completion = 6;
}

// DeductTokensResponse indicates whether the deduction succeeded.
message DeductTokensResponse {
  // success indicates whether grains were deducted.
  // true: Deduction successful, streaming can continue
  // false: Insufficient balance, SDK must kill stream immediately
  bool success = 1;

  // remaining_balance shows grains left after this deduction.
  // SDK can use this to warn when balance is critically low.
  int64 remaining_balance = 2;

  // error_code explains why deduction failed.
  // Only populated when success=false.
  // Possible values:
  // - INSUFFICIENT_BALANCE: Customer ran out of grains mid-stream
  // - INVALID_TOKEN: request_token doesn't match or expired
  // - REQUEST_NOT_FOUND: request_id doesn't exist in tracking system
  // - SERVICE_ERROR: Backend issue, SDK should retry
  string error_code = 3;
}

// FinalizeRequestRequest provides exact usage data for reconciliation.
message FinalizeRequestRequest {
  // customer_id identifies the customer.
  string customer_id = 1;

  // request_id identifies the request being finalized.
  string request_id = 2;

  // status indicates how the request ended.
  RequestStatus status = 3;

  // actual_prompt_tokens is the exact count from the AI provider's response.
  // Source: response.usage.prompt_tokens from OpenAI/Anthropic/etc.
  int32 actual_prompt_tokens = 4;

  // actual_completion_tokens is the exact count from the provider.
  // For killed streams, this is the SDK's count of delivered tokens.
  int32 actual_completion_tokens = 5;

  // total_actual_cost_grains is the precise cost calculated from exact tokens.
  // SDK calculates this using model pricing and exact token counts.
  int64 total_actual_cost_grains = 6;

  // model used for this request (for pricing lookup).
  string model = 7;
}

// RequestStatus indicates how a request completed.
enum RequestStatus {
  // STATUS_UNSPECIFIED should never be used, present for proto3 requirement.
  STATUS_UNSPECIFIED = 0;

  // COMPLETED_SUCCESS indicates natural completion with all tokens delivered.
  COMPLETED_SUCCESS = 1;

  // KILLED_INSUFFICIENT_BALANCE indicates SDK killed stream due to zero balance.
  KILLED_INSUFFICIENT_BALANCE = 2;

  // FAILED_ERROR indicates provider error or network failure.
  FAILED_ERROR = 3;

  // FAILED_TIMEOUT indicates request took too long and was abandoned.
  FAILED_TIMEOUT = 4;
}

// FinalizeRequestResponse returns the results of reconciliation.
message FinalizeRequestResponse {
  // success indicates whether finalization completed.
  bool success = 1;

  // refunded_grains shows the amount refunded due to overestimation.
  // Positive values indicate customer was refunded (most common).
  // Negative values indicate customer was charged additional grains.
  // Zero indicates perfect estimation (rare).
  int64 refunded_grains = 2;

  // final_balance shows customer's balance after reconciliation.
  int64 final_balance = 3;
}

// GetBalanceRequest queries current balance without side effects.
message GetBalanceRequest {
  // customer_id identifies the customer.
  string customer_id = 1;
}

// GetBalanceResponse returns current balance information.
message GetBalanceResponse {
  // balance is the customer's current grain balance.
  int64 balance = 1;

  // reserved is the amount currently locked by in-flight requests.
  int64 reserved = 2;

  // available is the actual spendable amount (balance - reserved).
  int64 available = 3;
}
